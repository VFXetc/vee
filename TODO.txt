

MAJOR TODOS
-----------

- permissions:

    - install_vee.py should add the setgid bit, and make chmod the whole thing
      to be readible by all. May need to sudo. It should assert that itself
      isn't sudo

      python install_vee.py --setgid vfx


    - need permission setting as a step in Package.install()

        - vee config --set os.umask 0002
        - vee config --set os.setgid vfx

- dev environment:

    - how to dev install?
        - `vee init --dev /path/to/other/vee [/path/to/dev]`
        - `vee --dev xxx` is a shortcut for setting VEE to discovered dev
        - `vee develop` does like `python setup.py develop`
        - may need a `Package.develop()` method
            - for git packages, it sets the package_path, and makes sure it
              exists
            - for non-git packages, it fails (for now)
            - it adds a dev link to the DB, or some metadata file (or its own
              .veedev.sqlite)

    - how to run in dev?
        - `vee runtime ENV` creates a shell for you to run it?
    - how to inherit environments?

- repo
    - how to structure?
    - how to manage?
    - how to manage resulting environments?
        - does it make sense to merge two repositories? Perhaps the structure
          must be that they be git submodules
        - make the concession that there is only a single repo ever attached

- key_base
    - entrypoints
    - apps: can we build them in a central location, outside of the isolated
      build environments, or is the Finder going to be able to adapt to symlinks
      in the Dock?
    - scrap history


---

- test python packages:
  - they import
  - they import each other
  - console_scripts entrypoints work
  - scripts work
  - their install_requires doesn't matter

- install data that comes with Python wheels
  $NAME-$VERSION.data dir at top-level, beside $NAME-$VERSION.dist-info
- install Python commands listed in egg-info

- vee.buildschemes.pyegg:PythonEggScheme
    - there can be a separate build and install scheme
    - consider changing "type" to "transport", so that there isn't the more
      generic "type"

- move database to $VEE/db.sqlite

- don't need to track all of the repo info; just leave that to git, and assume
  that we are using "origin"

- repo workflow
  
  √ `vee init [--name NAME] [--repo REPO]`
      Assert that the various directory structures exist, and add a new repo
      as a convenience

  √ `vee repo --add [--default] [--parent PATH] NAME REPO`
  √ `vee repo --remove NAME`
  √ `vee repo --list`

  x `vee clone OTHER_HOME NEW_HOME`
      - Do this later.

  √ `vee update`
  √ `vee upgrade`

- `vee exec` defaults to the default repo/remote/branch combo

- main environment could be called "master"

- linking could check if a previous revision of the same thing was already
  linked into an environment, and stop you

- parse_multiple_requirements(args) walks through a set of args, pulling out
  RequirementSet(s) when they are files that end in '.txt' (or no extendion),
  and requirements from the rest

- entrypoints.yml at top_level is built by Makefile (in sgfs and others)
    - make a build_metatools_entrypoints distutils command

- sgactions.yml at top_level is built by Makefile (in sgfs and others)
    - this becomes the user's problem

- how does this new Python install method deal with install_requires?
    - it doesn't! document it?

- Can we make each environment into a virtualenv too?
    - vendor virtualenv.py, or install it as a Package
    - call virtualenv.create_environment('test', no_setuptools=True, no_pip=True)

- s/Home/Vee/g ??

- we might need to rewrite all of the shebangs during linking to the virtual
  python

- etc/vee/environ/$name.txt is a file that contains environment variables
  provided by each package

- does it make sense to have packages/builds/installs in the database, instead
  of having them all together?

- build-subdir and install-prefix should be used to invalidate matches in the
  resolver

`vee config set chmod ugo=rwX` for vee to chmod everything writable by everyone
    - have this be a parameter of the install_vee.py script as well:
        python install_vee.py -c chmod=ugo=rwX

- does sitetools disprove the separate Python build/install process?

- git might need to use different revisions on different platforms (for homebrew/linuxbrew)
    - if this is the only attribute that matters in this way, then we can have a
        --linux-revision and --osx-revision which it picks from

- '--refresh' or --latest' or '--head' to always request the latest; this is a more general
  case of --force-fetch

- render_in_environ(list_or_dict, environ)
  - process the configuration this way too

- log everything about the different steps, and stuff it into the database
- CLI IO/API/logging package

    - name:
        x clio (on PyPI)
        - clout

    - styles (copied straight from what we have is cool)
    - io indenting model
        - replaces sys.stdout and sys.stderr, and those are pushed through
        - can spawn reader threads which can (1) buffer the output, (2) echo it, (3) push it to a callback
        - with clout.io.indent(), or clout.io.push_indent() and clout.io.pop_indent()
    - event log
        - format: "$datetime $stream $string-escaped-content"
        - events:
            - exec:$pid -> nth executable
            - arg:$pid:I -> argument I of nth exe
            - out:$pid -> stdout of nth exe
            - err:$pid -> stderr of nth exe

- Home.{package,build,install,environment}_root attributes
- Home.to_environ()

- `vee exec --latest name` looks for a "name/%" environment, and uses that

- `vee gc`
  - delete installs (and their DB records) which are not linked to
  - delete installs in DB that don't exist on disk
  - delete anything on disk that isn't referred to by the index
      build a set of relative paths (and all their ancestors), then walk the
      root looking for directories which aren't mentioned, then delete them

- record stdout/stderr from build process in the database. Use a timestamped
  format: each line starts with "out" or "err" and the timestamp

    out 2015-02-18T15:02:01 sdflkjsdf

- add functions to resolve_environ(): $VEE_INSTALLS
  - this requires either scanning for, or knowing about installed things

- Http/File/Base could do checksums of files to see if they have changed
  - memoize the caches based on inode,size,mtime

- test all the things!
  - libfoo, bar in Testbrew
  - http://localhost:10000/qux-1.0.0.tgz
  - git+git@github.com:mikeboers/norf

- cythonmagick is pulling in the "wrong" sqlite?

- wxfab fabric package for deploying and debugging these things

- `vee list` lists environments
- `vee list ENVIRONMENT` lists the various buildtimes of environments

- environment structure:
  $VEE/environments/$NAME/latest -> $BUILDTIME

- $VEE/repo structure
    
    managers/{name}.py
    environments/{name}.txt

    - default environment name is "master"
    - can we have updates to non-git environments?
        - `vee update` could pull in a new repo, and hash it to see if it
          changed


- dev

    - Builder class encapsulates the base building logic; can be overridden for
      DevBuilder (so that python can `python setup.py develop` instead)

    - DevManager proxies to the "normal" manager to fetch a package into the
      dev location, and in the case of Python packages build the egg-info so it
      knows how to link the environment.

    - `dev` then just discovers your dev environment, and merges its envvars
      on top of the master one.

    - sitetools is installed in the master one, and the tools which set envvars
      also setup KS_SITES (or a renamed versions). However, we won't really
      need KS_SITES since we are installing everything without .pth files.

    - !! How can we have a tool auto-update an environment.txt with the current
      git commits?

        - Scan your dev directory, looking for git repos with remotes that match
          the repos in the env.txt
        - See if the current commit differs from that which would be installed
          by the env.txt

    - use the standard managers for fetching/installing repos

    - `vee init git@git.westernx:westernx/veerepo /usr/local/vee`
    - `vee init --inherit-from /usr/local/vee ~/dev/vee-env`

        - the git repo it clones is the same that the indicated uses
        - the runtime will link against the master
        - a $VEE/config file (YAML) contains this sort of info:

          repo_requirement: git+git@git.westernx:westernx/veerepo --force-fetch --revision origin/master
          repo_install_path: /home/mboers/dev/vee-env/installs/veerepo/1.0.0
          parent_path: /usr/local/vee

    - `vee add [--major,--minor,--patch] .` add changes to the current package (likely a git repo) to the
      repo's environment file. The change-level flags increment the "version" flag, if set

    - `vee commit [-a] [--major|--minor|--patch] [-m MESSAGE]`] 
    - `vee push`




- commands

    vee init REPO
    vee update
    vee upgrade

    √ vee install REQUIREMENT
    - vee install -r requirements.txt
    √ vee link NAME REQUIREMENTS_FILE


LATER
-----

- `vee install xxx --make-install` to also `make install`

- custom managers
  - e.g. `vee install PyAV.py`, where PyAV.py contains:
        - REQUIREMENT = 'https://pypi.python.org/packages/source/a/av/av-0.2.2.tar.gz#md5=ec0198f28d9294d20b54b0ac3a9ff77d'
        - DEPENDS_ON = ['lib:ffmpeg']
        - MANAGER or PyAVManager or PyavManager, which inherits from BaseManager

- pypi manager
    - PyPI JSON API -> https://pypi.python.org/pypi/%s/json
    - Need to either hit the PyPI on every `.installed` check, or cache versions.

- match how Homebrew links directories, or at least be smarter about it

- homebrew taps: homebrew+mikeboers/testbrew/foo
    - we would need a way to detect which tap it is
    - we can grep `brew info $forumla` for From: https://github.com/#{user}/#{repo}/blob/master/#{path}

- Homebrew is only installing the tree of the one package, not any of the
  dependencies. It should also link the dependencies. Perhaps there should be
  a Requirements.dependencies() which returns them all, and then makes
  sure they are all linked.

  Another solution to this problem is to have paths_to_install() return a list.

  Another solution is for HomebrewManager.install() to do this itself

  An AbstractRequirement is one like "lib:ffmpeg", "py:yaml", etc., that just
  know what result they want, but not where it is from. A DependencyInterface
  could be the intersection of AbstractRequirement and Requirement, such that

  Requirement.dependencies() can return real ones (e.g. from `brew deps`)
  and abstract ones. It is permitted to return different dependencies on each
  call (as they are discovered, e.g.)

  DependencyResolver can take a pool of requirements and figure out what order
  they should be installed in (via C3)

        .add(requirement)
        .rescan_dependencies()
        .linearize()


