
- test all the things!
  - libfoo, bar in Testbrew
  - http://localhost:10000/qux-1.0.0.tgz
  - git+git@github.com:mikeboers/norf

- cythonmagick is pulling in the "wrong" sqlite?


- RequirementSet class which encapsulates a requirements file, including comments,
  and file-wide environment variables.

  e.g.: PKG_CONFIG_PATH=$VEE/packages/homebrew/lib/pkgconfig

  - Requirement.set -> the set that it is a part of; can be none; allows for
    resolving the environment in a set without having to put that envvar in
    each requirement


- wxfab fabric package for deploying and debugging these things


- `vee list` lists environments
- `vee list ENVIRONMENT` lists the various buildtimes of environments


- environment structure:
  $VEE/environments/$NAME/latest -> $BUILDTIME


- `vee config` / vee.config.Config

- $VEE/repo structure
    
    managers/{name}.py
    environments/{name}.txt

    - default environment name is "master"
    - can we have updates to non-git environments?
        - `vee update` could pull in a new repo, and hash it to see if it
          changed


- dev

    - Builder class encapsulates the base building logic; can be overridden for
      DevBuilder (so that python can `python setup.py develop` instead)

    - DevManager proxies to the "normal" manager to fetch a package into the
      dev location, and in the case of Python packages build the egg-info so it
      knows how to link the environment.

    - `dev` then just discovers your dev environment, and merges its envvars
      on top of the master one.

    - sitetools is installed in the master one, and the tools which set envvars
      also setup KS_SITES (or a renamed versions). However, we won't really
      need KS_SITES since we are installing everything without .pth files.

    - !! How can we have a tool auto-update an environment.txt with the current
      git commits?

        - Scan your dev directory, looking for git repos with remotes that match
          the repos in the env.txt
        - See if the current commit differs from that which would be installed
          by the env.txt

    - use the standard managers for fetching/installing repos

    - `vee init git@git.westernx:westernx/veerepo /usr/local/vee`
    - `vee init --inherit-from /usr/local/vee ~/dev/vee-env`

        - the git repo it clones is the same that the indicated uses
        - the runtime will link against the master
        - a $VEE/config file (YAML) contains this sort of info:

          repo_requirement: git+git@git.westernx:westernx/veerepo --force-fetch --revision origin/master
          repo_install_path: /home/mboers/dev/vee-env/installs/veerepo/1.0.0
          parent_path: /usr/local/vee

    - `vee add [--major,--minor,--patch] .` add changes to the current package (likely a git repo) to the
      repo's environment file. The change-level flags increment the "version" flag, if set

    - `vee commit [-a] [--major|--minor|--patch] [-m MESSAGE]`] 
    - `vee push`



- We could use some sort of builds/index.db in order to find existing builds
  and environments

  SQLite schema:

    migrations: lift this from my web projects

    installs:
        
        - id
        - package_path
        - build_path
        - install_path
        - created_at
        - user_specification (normalized via Package.__str__)
        - manager (without options)
        - package (without options)

        Below can be provided by the user, but also discovered at build time.
        package.setattr('version', version, specificity=4) # stores the highest specificity
            _version_specificity stores the current specificity

        - name (defaults to $package)
        - version
        - revision

    environments:

        - id
        - name
        - version
        - revision
        - user_specification

    links:

        - id
        - env_id
        - install_id



- something to report on what is already linked into and environment:
    - $environment/etc/vee.txt
    - $environment/etc/vee.db
    - $environment/etc/vee/links/$install_name.txt
      this could contain all of the symlinks created







- commands

    vee init REPO
    vee update
    vee upgrade

    √ vee install REQUIREMENT
    - vee install -r requirements.txt
    √ vee link NAME REQUIREMENTS_FILE


LATER
-----

- custom managers
  - e.g. `vee install PyAV.py`, where PyAV.py contains:
        - REQUIREMENT = 'https://pypi.python.org/packages/source/a/av/av-0.2.2.tar.gz#md5=ec0198f28d9294d20b54b0ac3a9ff77d'
        - DEPENDS_ON = ['lib:ffmpeg']
        - MANAGER or PyAVManager or PyavManager, which inherits from BaseManager

- pypi manager
    - PyPI JSON API -> https://pypi.python.org/pypi/%s/json
    - Need to either hit the PyPI on every `.installed` check, or cache versions.

- match how Homebrew links directories

- homebrew taps: homebrew+mikeboers/testbrew/foo
    - we would need a way to detect which tap it is
    - we can grep `brew info $forumla` for From: https://github.com/#{user}/#{repo}/blob/master/#{path}

- Homebrew is only installing the tree of the one package, not any of the
  dependencies. It should also link the dependencies. Perhaps there should be
  a Requirements.dependencies() which returns them all, and then makes
  sure they are all linked.

  Another solution to this problem is to have paths_to_install() return a list.

  Another solution is for HomebrewManager.install() to do this itself

  An AbstractRequirement is one like "lib:ffmpeg", "py:yaml", etc., that just
  know what result they want, but not where it is from. A DependencyInterface
  could be the intersection of AbstractRequirement and Requirement, such that

  Requirement.dependencies() can return real ones (e.g. from `brew deps`)
  and abstract ones. It is permitted to return different dependencies on each
  call (as they are discovered, e.g.)

  DependencyResolver can take a pool of requirements and figure out what order
  they should be installed in (via C3)

        .add(requirement)
        .rescan_dependencies()
        .linearize()


